(ns cameleon.http-client-mock
  (:require [clojure.string :as str]
            [cameleon.utils :as utils]
            [cameleon.io :as io]
            [cameleon.http :as http]
            [cameleon.rest :as rest]
            [cameleon.uri-matcher :as urimat]
            [promesa.core :as p]
            [httpurr.protocols :as hp]
    #?(:clj [byte-streams :as bytes])
    )
  #?(:clj (:import [java.io InputStream]))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utility functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; convenience: code using this library does not need cameleon.http just for that
(def default-client http/default-client)

(defn mock-response
  "Return an httpurr Response object returning values given either from a
  response map, or from another Response object. In Java, if the given
  Response object has a response body of type InputStream, the returned
  Response object will have a response body transferred to a byte array,
  so it can be read multiple times. Otherwise, as well as in ClojureScript,
  a Response object is returned as is."
  [response]
  (cond
    (map? response) (reify hp/Response
                      (-success? [_] true)
                      (-response [_] response)
                      (-error [_] nil))
    (satisfies? hp/Response response)
    #?(:cljs response
       :clj (if (instance? java.io.InputStream
                           (-> response hp/-response :body))
              ;; NOTE: using update-in to convert body did not work, as if it's
              ;; reading the input stream before anything else can
              (let [ba (-> response hp/-response :body bytes/to-byte-array)]
                (reify hp/Response
                  (-success? [_] (hp/-success? response))
                  (-response [_] (assoc (hp/-response response) :body ba))
                  (-error [_] (hp/-error response))))
              response))
    :else (ex-info "Invalid argument" {:response response})
    )
  )

(defn mock-error?
  "True if the given error is generated by a mock, nil otherwise."
  [error]
  (some-> error
          ex-data
          :mock-error?))

(defn mock-error
  "Return an error using ex-info so that mock-error? returns true on it.
  Should be used in place of ex-info by any mock."
  ([msg-or-mock-error]
   (mock-error msg-or-mock-error nil))
  ([msg-or-mock-error data]
   (if (and (empty? data) (mock-error? msg-or-mock-error))
     msg-or-mock-error
     (let [data (merge (utils/error->map msg-or-mock-error)
                       (cond
                         (nil? data) {}
                         (map? data) data
                         :else {:data data}))
           msg (or (:message data) "Mock error")]
       (ex-info msg (assoc data :mock-error? true))))))

(defn mock-error-response
  "Return an httpurr Response object with the given error message and data,
  or the given mock error."
  ([msg-or-mock-error]
   (reify hp/Response
     (-success? [_] false)
     (-response [_] nil)
     (-error [_] (mock-error msg-or-mock-error))))
  ([msg data]
   (mock-error-response (mock-error msg data))))

(defn- handle-exception
  [error-handling-fn f & args]
  (try
    (apply f args)
    (catch #?(:clj Throwable :cljs :default) e
      (error-handling-fn e))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Simple mocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn client-returning
  "Return an httpurr client that does not need any network and always return
  a given payload."
  ([body]
   (client-returning 200 nil body))
  ([status headers body]
   (reify hp/Client
     (-send [_ request _]
       (reify hp/Request
         (-listen [_ cb]
           ;; we don't want to call cb right away, it's a callback!
           (p/then
            (p/resolved (mock-response (-> {:status status
                                            :body body}
                                           (cond->
                                             (not (empty? headers))
                                               (assoc :headers headers)))))
            cb)))))))

(defn failing-client
  "Return an httpurr client that always fail with the given error message
  or mock error."
  ([]
   (failing-client nil))
  ([msg-or-mock-error]
   (let [msg (or msg-or-mock-error "Mock error from failing-client.")]
     (reify hp/Client
       (-send [_ request _]
         (reify hp/Request
           (-listen [_ cb]
             ;; we don't want to call cb right away, it's a callback!
             (p/then
              (p/resolved (mock-error-response msg {:request request}))
              cb))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Wrapping/overriding mocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn mock-from-fn
  "Return an httpurr client returning the response form a handler fn.
  The handler-fn must take 2 arguments and return an httpurr Response object.
  The first argument is the original httpurr request map, the second is the
  options map."
  [handler-fn]
  (reify hp/Client
    (-send [_ request options]
      (reify hp/Request
        (-listen [_ cb]
          ;; we don't want to call cb right away, it's a callback!
          (p/then
           (p/resolved (handle-exception mock-error-response
                                         handler-fn request options))
           cb))))))

(defn wrap-response
  "Wraps an existing httpurr client using a handler function that can intercept
  the wrapped client response. Useful to record or tweak responses.
  The handler-fn must take 3 arguments and return an httpurr Response object.
  The first argument is the original httpurr request map, the second is the
  options map, the third is the response object returned by the wrapped client."
  [client handler-fn]
  (reify hp/Client
    (-send [_ request options]
      (let [wrapped-req-obj (hp/-send client request options)]
        (reify hp/Request
          (-listen [_ cb]
            (let [wrapping-cb (fn [client-resp]
                                (cb (handle-exception mock-error-response
                                                      handler-fn request options
                                                      (mock-response
                                                       client-resp))))]
              (hp/-listen wrapped-req-obj wrapping-cb))))))))

(defn wrap-request
  "Wraps an existing httpurr client using a handler function that can intercept
  the request and options maps before being passed to the wrapped client.
  Useful to record or tweak requests and options.
  The handler-fn must take 2 arguments and return a vector pair in the form
  [request-map options-map].
  The first argument is the original httpurr request map, the second is the
  options map."
  [client handler-fn]
  (reify hp/Client
    (-send [_ request options]
      (let [[new-req new-opts] (handle-exception mock-error-response
                                                 handler-fn request options)]
        (hp/-send client new-req new-opts)))))

(defn override
  "Override an httpurr client with another, that is, the overriding client is
  invoked first and if it returns a response object that satisfies a given
  predicate, that response is returned without invoking the overriden
  client, otherwise the latter is invoked for servicing the request.
  The overriden client is optional and defaults to cameleon.http default.
  The predicate is optional and defaults to httpurr.protocols/-success?.
  Typical use case: mock certain requests and let others through the wire."
  ([overriding-client]
   (override overriding-client (default-client) hp/-success?))
  ([overriding-client overriden-client]
   (override overriding-client overriden-client hp/-success?))
  ([overriding-client overriden-client override-when-pred]
   (reify hp/Client
     (-send [_ request options]
       (let [wrapped-req-obj (hp/-send overriding-client request options)]
         (reify hp/Request
           (-listen [_ cb]
             (let [wrapping-cb (fn [client-resp]
                                 (let [ro (mock-response client-resp)]
                                   (if (override-when-pred ro)
                                     (cb ro)
                                     (let [wrapped-req-obj
                                           (hp/-send overriden-client request
                                                     options)]
                                       (hp/-listen wrapped-req-obj cb)))))]
               (hp/-listen wrapped-req-obj wrapping-cb)))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Data-driven mock
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- client-mock-response
  [compiled-uris responses request _]
  (let [{:keys [url method]} request
        {:keys [main-handler route-handler] :as matched-uri}
        (urimat/match-uri compiled-uris url method)
        r (get responses [main-handler route-handler])]
    (cond
      (nil? r) (mock-error-response "URL not mocked" {:request request
                                                      :matched-uri matched-uri})
      (map? r) (mock-response r)
      (fn? r) (try
                (mock-response (r request matched-uri))
                (catch #?(:cljs :default :clj Throwable) e
                  (mock-error-response e {:request request
                                          :matched-uri matched-uri})))
      :else (mock-error-response "Invalid mock response (bug)"
                                 {:response r
                                  :request request
                                  :matched-uri matched-uri}))))

(defn client-mock
  "Return an httpurr client that returns a payload that can vary depending
  on the request.
  Mapping between a URL and the response to return is a two step process
  hence the need for two arguments.
  The first step/argument is a list of uris as expected by cameleon.uri-matcher.
  The second step/argument is a map from handlers, as returned by
  cameleon.uri-matcher/match-uri in the first step, to response maps or function
  that return a response map given the request map and match-uri result map.
  Response maps should be as expected by funcool/httpurr, meaning they must
  contain at least 2 entries for :status and :body, and optionally a
  :headers map from strings to strings.
  If an incoming request is not mapped, a failed response object is returned
  which will be surfaced as an exception by httpurr unless overriden."
  [uris responses]
  (mock-from-fn (partial client-mock-response
                         (urimat/compile-uris uris)
                         responses)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Session recording
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def empty-session {:req-opts-resp [] ;; vector of [req opts resp] in the order
                                      ;; they were recorded
                    :req-opts->responses {} ;; map from [req opts] to a vector of
                                            ;; response objects or response maps
                                            ;; in the order they were recorded
                    })

(defn new-session
  "Return an new empty session ref ready for recording into."
  []
  (atom empty-session))

(defn- conj-same
  "Append x to the end of vector v, but if x is equal to the last element of v,
  then append the last element instead. Lowers memory usage when repetitively
  adding objects equal in value but not in reference."
  [v x]
  (let [last (last v)
        x (if (= x last) last x)]
    (conj v x)))

(defn- record-entry
  [session request-map options response-object]
  (let [s (update-in session [:req-opts-resp]
                     conj [request-map options response-object])
        k [request-map options]
        ks [:req-opts->responses k]]
    (if (get-in s ks)
      (update-in s ks conj-same response-object)
      (assoc-in s ks [response-object]))))

(defn- recording-handler
  [session-ref request-map options response-object]
  (swap! session-ref record-entry request-map options response-object)
  response-object)

(defn record-into
  "Return a mock that records requests and responses into a session
  that can later be used by other mocks.
  session must be a ref which can be re-used across multiple recording sessions.
  Use new-session to create a fresh and empty session ref (atom).
  If a client to record from is not provided, it records from the default
  cameleon.http client."
  ([session]
   (record-into session (default-client)))
  ([session client]
   (wrap-response client (partial recording-handler session))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Save/read recorded session to/from file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- serialise-body
  [response]
  (let [headers (:headers response)
        ct (get headers "content-type" (get headers "Content-Type"))
        add-clj-body #(assoc % :clj-body (-> % :body rest/parse-json))
        r (http/body-to-string response)]
    (if (and ct (str/starts-with? ct "application/json"))
      (add-clj-body r) ;; easier to read/compare
      r)))

(defn- serialise-response
  [response-object]
  (let [success? (hp/-success? response-object)]
    {:success? success?
     :response (when success? (-> response-object
                                  hp/-response
                                  ;http/body-to-string
                                  serialise-body))
     :error (when (not success?)
              (let [err (hp/-error response-object)]
                (when err (str err))))}))

(defn make-serialisable
  "Transform a recorded session into a form that can be serialised (e.g.
  in an edn file)."
  [session]
  (if (:serialised? session)
    session
    (reduce (fn [s [req opts resp]]
              (record-entry s req opts (serialise-response resp)))
            (assoc empty-session :serialised? true)
            (:req-opts-resp session))))

(defn write-session
  "Write session into an edn file.
  The session argument must be a session value, not a ref, and the file
  argument must be anything that cameleon.io/to-file can recognise."
  [file session]
  (println "Writing" (str file))
  (->> session
       make-serialisable
       (io/write-edn-to file)))

(defn read-session
  "Read session from an edn file.
  The file argument must be anything that cameleon.io/to-file can recognise."
  [file]
  (println "Reading" (str file))
  (cameleon.io/read-edn-from file))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Mocks that work from a recorded session
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- rotating-index
  "Given the need to iterate over all elements of an array, and to rotate back
  at index 0 once the end of the array is reached, this function returns the
  index position to look up at iteration n.
  The first argument is the size of the array, and n is the iteration
  number, starting from 1.
  So with an array of size 3:
  (rotating-index 3 1) => 0
  (rotating-index 3 2) => 1
  (rotating-index 3 3) => 2
  (rotating-index 3 4) => 0
  (rotating-index 3 5) => 1
  (rotating-index 3 6) => 2
  (rotating-index 3 7) => 0
  ...
  "
  [size n]
  (let [m (mod n size)]
    (if (zero? m) (dec size) (dec m))))

(defn- mock-from-recorded-handler-fn
  [session playback-state request-map options]
  (let [k [request-map options]
        s (swap! playback-state utils/update-frequency k)
        responses (get-in session [:req-opts->responses k])
        response (when responses
                   (nth responses (rotating-index (count responses)
                                                  (get s k))))]
    (cond
      (empty? responses) (mock-error-response
                          "Request not found in recorded session"
                          {:request request-map
                           :options options
                           :session session})
      (map? response) (reify hp/Response
                        (-success? [_] (:success? response))
                        (-response [_] (:response response))
                        (-error [_] (:error response)))
      (nil? response) (mock-error-response
                       "Nil response in recorded session (bug)"
                       {:request request-map
                        :options options
                        :session session})
      :else response)))

(defn mock-from-recorded
  "Return a client that uses a recorded session to mock responses.
  The session argument is the actual session map (not a ref) as recorded
  originally, or its deserialised form, or if it's not a map it must
  be something that cameleon.io/to-file can recognise to load the session from.
  Playing back a session means looking up a request+options in the session and
  returning the next response available for that request+options.
  If a request has been recorded 3 times, 3 responses have been recorded,
  they will be returned in the same order in a continuous loop.
  If a request is not found in the session, a failed response object is returned
  which will be surfaced as an exception by httpurr unless overriden."
  [session]
  (let [session (if (map? session)
                  session
                  (read-session session))
        playback-state (atom {})
        handler-fn (partial mock-from-recorded-handler-fn session playback-state)]
    (mock-from-fn handler-fn)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Convenience function to mock from various sources
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn mock-from
  "Convenience function that returns an httpurr client that mock responses
  from the given input. Depending on the arguments this function calls either
  mock-from-fn, mock-from-recorded, or client-mock."
  ([fn-or-session]
   (cond
     (nil? fn-or-session) (ex-info "nil mock-from argument" {})
     (fn? fn-or-session) (mock-from-fn fn-or-session)
     :else (mock-from-recorded fn-or-session)))
  ([uris responses]
   (client-mock uris responses)))
